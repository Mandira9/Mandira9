LAB-01

#include<windows.h>
#include<stdio.h>
#include<math.h>
#include<GL/glut.h>
GLint X1,Y1,X2,Y2;
void LineBres(void)
{
	glClear(GL_COLOR_BUFFER_BIT);
	int dx=abs(X2-X1),dy=abs(Y2-Y1);
	int p=2*dy-dx;
	int twoDy=2*dy,twoDyDx=2*(dy-dx);
	int x,y;
	if(X1>X2)
	{
		x=X2;
		y=Y2;
		X2=X1;
	}
	else
	{
		x=X1;
		y=Y1;
		X2=X2;
	}
	glBegin(GL_POINTS);
	glVertex2i(x,y);
	while(x<X2)
	{
		x++;
		if(p<0)
			p+=twoDy;
		else
		{
			y++;
			p+=twoDyDx;
		}
		glVertex2i(x,y);
	}
	glEnd();
	glFlush();
}
void Init()
{
	glClearColor(1.0,1.0,1.0,0);
	glColor3f(0.0,0.0,0.0);
	glPointSize(8.0);
	glViewport(0,0,50,50);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluOrtho2D(0,50,0,50);
}
int main(int argc,char **argv)
{
	printf("enter two points for draw lineBresenham:\n");
	printf("\n enter point1(X1,Y1):");
scanf("%d%d",&X1,&Y1);
printf("\n enter point2(X2,Y2):");
scanf("%d%d",&X2,&Y2);
glutInit(&argc,argv);
glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
glutInitWindowSize(300,400);
glutInitWindowPosition(0,0);
glutCreateWindow("LineBresenham");
Init();
glutDisplayFunc(LineBres);
glutMainLoop();
}

LAB-02

#include<windows.h>
#include<GL/glu.h>
#include<GL/glut.h>
#include<stdio.h>
GLfloat px,py,R;
void Draw()
{
    glClear(GL_COLOR_BUFFER_BIT);
    glColor3f(0,0,1);
    glBegin(GL_LINE_LOOP);
    glVertex2f(0.1,0.4);
    glVertex2f(0.7,0.4);
    glVertex2f(0.4,0.8);
    glEnd();

    glLoadIdentity();
    glTranslatef(px,py,0);
    glRotatef(R,0,0,1);
    glTranslatef(-px,-py,0);

    glColor3f(1,0,0);
    glBegin(GL_LINE_LOOP);
    glVertex2f(0.1,0.4);
    glVertex2f(0.7,0.4);
    glVertex2f(0.4,0.8);
    glEnd();
    glFlush();

}
int main(int argc, char *argv[ ])
{
    printf("Enter the Rotation referencepoint[pivot point]");
    scanf("%f%f",&px,&py);
    printf("Enter the Rotation Degree\n");
    scanf("%f",&R);
    glutInit(&argc,argv);
    glutInitDisplayMode(GLUT_RGB| GLUT_SINGLE);
    glutInitWindowPosition(0,0);
    glutInitWindowSize(500,500);
    glutCreateWindow("Triangle Rotation");
    glutDisplayFunc(Draw);
    glutMainLoop();
    return 0;
}

LAB-03

#include<windows.h>
#include <stdlib.h>
#include <GL/glut.h>

        GLfloat vertices[][3] = {{-1.0,-1.0,-1.0},{1.0,-1.0,-1.0},
        {1.0,1.0,-1.0}, {-1.0,1.0,-1.0}, {-1.0,-1.0,1.0},
        {1.0,-1.0,1.0}, {1.0,1.0,1.0}, {-1.0,1.0,1.0}};


        GLfloat colors[][3] = {{0.0,0.0,0.0},{1.0,0.0,0.0},
        {1.0,1.0,0.0}, {0.0,1.0,0.0}, {0.0,0.0,1.0},
        {1.0,0.0,1.0}, {1.0,1.0,1.0}, {0.0,1.0,1.0}};

void polygon(int a, int b, int c , int d)
{
         glBegin(GL_POLYGON);
                glColor3fv(colors[a]);
                glVertex3fv(vertices[a]);

                glColor3fv(colors[b]);
                glVertex3fv(vertices[b]);

                glColor3fv(colors[c]);
                glVertex3fv(vertices[c]);

                glColor3fv(colors[d]);
                glVertex3fv(vertices[d]);
        glEnd();
                                                                                                                                                                                                                }

void colorcube(void)
{
        polygon(0,3,2,1);
        polygon(2,3,7,6);
        polygon(0,4,7,3);
        polygon(1,2,6,5);
        polygon(4,5,6,7);
        polygon(0,1,5,4);
}
static GLfloat theta[] = {0.0,0.0,0.0};
static GLint axis = 2;

void display(void)
{
 glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        glLoadIdentity();
        glRotatef(theta[0], 1.0, 0.0, 0.0);
        glRotatef(theta[1], 0.0, 1.0, 0.0);
        glRotatef(theta[2], 0.0, 0.0, 1.0);
        colorcube();
        glFlush();
        glutSwapBuffers();
}
void spinCube()
{
        theta[axis] += 1.0;
        if( theta[axis] > 360.0 ) theta[axis] -= 360.0;
        /* display(); */
        glutPostRedisplay();
}

void mouse(int btn, int state, int x, int y)
{
    if(btn==GLUT_LEFT_BUTTON && state == GLUT_DOWN) axis = 0;
    if(btn==GLUT_MIDDLE_BUTTON && state == GLUT_DOWN) axis = 1;
    if(btn==GLUT_RIGHT_BUTTON && state == GLUT_DOWN) axis = 2;
}

void myReshape(int w, int h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h)
        glOrtho(-2.0, 2.0, -2.0 * (GLfloat) h / (GLfloat) w,
            2.0 * (GLfloat) h / (GLfloat) w, -10.0, 10.0);
    else
        glOrtho(-2.0 * (GLfloat) w / (GLfloat) h,
            2.0 * (GLfloat) w / (GLfloat) h, -2.0, 2.0, -10.0, 10.0);
    glMatrixMode(GL_MODELVIEW);
}


int main(int argc, char **argv)
{
   glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
    glutInitWindowSize(500, 500);
    glutCreateWindow("Rotating a Color Cube");
    glutReshapeFunc(myReshape);
    glutDisplayFunc(display);
    glutIdleFunc(spinCube);
    glutMouseFunc(mouse);
    glEnable(GL_DEPTH_TEST);
    glutMainLoop();
}

LAB-04

#include<windows.h>
#include<stdlib.h>
#include<GL/glut.h>
GLfloat vertices[][3]={{-1.0,-1.0,-1.0},{1.0,-1.0,-1.0},
{1.0,1.0,-1.0},{-1.0,1.0,-1.0},{-1.0,-1.0,1.0},
{1.0,-1.0,1.0},{1.0,1.0,1.0},{-1.0,1.0,1.0}};
GLfloat colors[][3]={{0.0,0.0,0.0},{1.0,0.0,0.0},
{1.0,1.0,0.0},{0.0,1.0,0.0},{0.0,0.0,1.0},
{1.0,0.0,1.0},{1.0,1.0,1.0},{0.0,1.0,1.0}};

void polygon(int a, int b, int c, int d)
{
	glBegin(GL_POLYGON);
		glColor3fv(colors[a]);
		glVertex3fv(vertices[a]);
		glColor3fv(colors[b]);
		glVertex3fv(vertices[b]);
		glColor3fv(colors[c]);
		glVertex3fv(vertices[c]);
		glColor3fv(colors[d]);
		glVertex3fv(vertices[d]);
	glEnd();
}

void colorcube()
{
	polygon(0,3,2,1);
	polygon(2,3,7,6);
	polygon(0,4,7,3);
	polygon(1,2,6,5);
	polygon(4,5,6,7);
	polygon(0,1,5,4);
}

static GLfloat theta[]={0.0,0.0,0.0};
static GLint axis=2;
static GLdouble viewer[]={0.0,0.0,5.0};

void display(void)
{
	glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
	glLoadIdentity();
	gluLookAt(viewer[0], viewer[1],viewer[2],0.0,0.0,0.0,
0.0,1.0,0.0);
	glRotatef(theta[0],1.0,0.0,0.0);
	glRotatef(theta[1],0.0,1.0,0.0);
	glRotatef(theta[2],0.0,0.0,1.0);
	colorcube();
	glFlush();
	glutSwapBuffers();
}

void mouse(int btn, int state, int x, int y)
{
	if(btn==GLUT_LEFT_BUTTON && state==GLUT_DOWN) axis=0;
	if(btn==GLUT_MIDDLE_BUTTON&&state==GLUT_DOWN) axis=1;
	if(btn==GLUT_RIGHT_BUTTON&&state==GLUT_DOWN) axis=2;
	theta[axis]+=2.0;
	if(theta[axis]>360.0) theta[axis]-=360.0;
	display();
}

void keys(unsigned char key, int x, int y)
{
	if(key == 'x') viewer[0]-=1.0;
	if(key == 'X') viewer[0]+=1.0;
	if(key == 'y') viewer[1]-=1.0;
	if(key == 'Y') viewer[1]+=1.0;
	if(key == 'z') viewer[2]-=1.0;
	if(key == 'Z') viewer[2]+=1.0;
	display();
}

void myReshape(int w, int h)
{
	glViewport(0,0,w,h);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	if(w<=h)
 glFrustum(-2.0,2.0,-2.0*(GLfloat)h/(GLfloat)w,
2.0*(GLfloat)h/(GLfloat)w, 2.0,20.0);
	else
glFrustum(-2.0,2.0,-2.0*(GLfloat)w/(GLfloat)h,
2.0*(GLfloat)w/(GLfloat)h, 2.0,20.0);
	glMatrixMode(GL_MODELVIEW);
}
int main(int argc, char **argv)
{
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_DOUBLE|GLUT_RGB|GLUT_DEPTH);
	glutInitWindowSize(500,500);
	glutCreateWindow("Colorcube Viewer");
	glutReshapeFunc(myReshape);
	glutDisplayFunc(display);
	glutMouseFunc(mouse);
	glutKeyboardFunc(keys);
	glEnable(GL_DEPTH_TEST);
	glutMainLoop();
}

LAB-06

#include<windows.h>
#include<gl/glut.h>
void obj(double tx,double ty,double tz,double sx,double sy,double sz)
{
	glRotated(50,0,1,0);
	glRotated(10,-1,0,0);
	glRotated(11.7,0,0,-1);

	glTranslated(tx,ty,tz);
	glScaled(sx,sy,sz);
	glutSolidCube(1);
	glLoadIdentity();
}
void display()
{
	glViewport(0,0,700,700);
	glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);

	obj(0,0,0.5,1,1,0.04);  
	obj(0,-0.5,0,1,0.04,1);
	obj(-0.5,0,0,0.04,1,1);

	obj(0,-0.3,0,0.02,0.2,0.02);   
	obj(0,-0.3,-0.4,0.02,0.2,0.02);
	obj(0.4,-0.3,0,0.02,0.2,0.02);
	obj(0.4,-0.3,-0.4,0.02,0.2,0.02);

	obj(0.2,-0.18,-0.2,0.6,0.02,0.6);  

	glRotated(50,0,1,0);
	glRotated(10,-1,0,0);
	glRotated(11.7,0,0,-1);

	glTranslated(0.3,-0.1,-0.3);
	glutSolidTeapot(0.09);
	glFlush();
	glLoadIdentity();
}
int main()
{
	float ambient[]={1,1,1,1};
	float light_pos[]={27,80,2,3};
	glutInitWindowSize(700,700);
	glutCreateWindow("scene");
	glutDisplayFunc(display);
	glEnable(GL_LIGHTING);
	glEnable(GL_LIGHT0);
	glMaterialfv(GL_FRONT,GL_AMBIENT,ambient);
	glLightfv(GL_LIGHT0,GL_POSITION,light_pos);
	glEnable(GL_DEPTH_TEST);
	glutMainLoop();
}

LAB-07

#include<windows.h>
#include<stdlib.h>
#include<stdio.h>
#include<GL/glut.h>
typedef float point[3];
point v[]={{0.0,0.0,1.0},{0.0,1.0,0.0},
{-1.0,-0.5,0.0}, {1.0,-0.5,0.0}};
int n;

void triangle(point a,point b,point c)
{
	glBegin(GL_POLYGON);
	  glVertex3fv(a);
	  glVertex3fv(b);
	  glVertex3fv(c);
	glEnd();
}
void divide_triangle(point a,point b,point c,int m)
{
	point v1,v2,v3;
	int j;
	if(m>0)
	{
		for(j=0;j<3;j++)
			v1[j]=(a[j]+b[j])/2;
		for(j=0;j<3;j++)
			v2[j]=(a[j]+c[j])/2;
		for(j=0;j<3;j++)
			v3[j]=(c[j]+b[j])/2;
		divide_triangle(a,v1,v2,m-1);
		divide_triangle(c,v2,v3,m-1);
		divide_triangle(b,v3,v1,m-1);
	}
	else(triangle(a,b,c));
}
void tetrahedron(int m)
{
	glColor3f(1.0,0.0,0.0);
	divide_triangle(v[0],v[1],v[2],m);
	glColor3f(0.0,1.0,0.0);
	divide_triangle(v[3],v[2],v[1],m);
	glColor3f(0.0,0.0,1.0);
	divide_triangle(v[0],v[3],v[1],m);
	glColor3f(0.0,0.0,0.0);
	divide_triangle(v[0],v[2],v[3],m);
}
void display(void)
{
	glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
	glLoadIdentity();
	tetrahedron(n);
	glFlush();
}
void myReshape(int w,int h)
{
	glViewport(0,0,w,h);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	if(w<=h)
		glOrtho(-2.0,2.0,-2.0*(GLfloat)h/(GLfloat)w,
2.0*(GLfloat)h/(GLfloat)w,-10.0,10.0);
	else
glOrtho(-2.0*(GLfloat)w/(GLfloat)h,
2.0*(GLfloat)w/(GLfloat)h,-2.0,2.0,-10.0,10.0);
	glMatrixMode(GL_MODELVIEW);
	glutPostRedisplay();
}
int main(int argc,char **argv)
{
	printf("No of Division: ");
scanf("%d",&n);
glutInit(&argc,argv);
glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB|GLUT_DEPTH);
glutCreateWindow("3D gasket");
glutReshapeFunc(myReshape);
glutDisplayFunc(display);
glEnable(GL_DEPTH_TEST);
glClearColor(1.0,1.0,1.0,0.0);
glutMainLoop();
}

LAB-08

#include<windows.h>
#include<GL/glut.h>
#include<math.h>
#include<stdio.h>
#define pi 3.1416

static int win;
static float th = 0;
typedef float point[2];

point p1[] = { { 2,10 },{ 3,11 },{ 5,9 },{ 6,10 } };
float u[] = { 0,0.10,0.20,0.30,0.40,0.50,0.60,0.70,0.80,0.90,1 };
point des[100];
float color1[3] = { 0.5,0.5,0.5 };
float color2[3] = { 0.5,0.5,0.5 };


void config(int w, int y)
{
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluOrtho2D(0.0, 20.0, 0.0, 20.0);
	glMatrixMode(GL_MODELVIEW);
}

void curve()
{
	for (int i = 0; i < 11; i++)
	{
		des[i][0] = (pow((1 - u[i]), 3)*p1[0][0]) + (3 * (u[i] * pow((1 - u[i]), 2)*p1[1][0])) + 3 * pow(u[i], 2)*(1 - u[i])*p1[2][0] + pow(u[i], 3)*p1[3][0];
		des[i][1] = (pow((1 - u[i]), 3)*p1[0][1]) + (3 * (u[i] * pow((1 - u[i]), 2)*p1[1][1])) + 3 * pow(u[i], 2)*(1 - u[i])*p1[2][1] + pow(u[i], 3)*p1[3][1];
	}

	glBegin(GL_LINE_STRIP);
	for (int i = 0; i < 11; i++)
	{
		glVertex2fv(des[i]);
	}
	glEnd();
}
void render()
{
	glClear(GL_COLOR_BUFFER_BIT);
	glClearColor(1.0, 1.0, 1.0, 1.0);
	glLineWidth(4.0);
	glPushMatrix();
	glColor3fv(color1);
	for (int i = 0; i < 20; i++)
	{
		glTranslatef(0,0.05, 0.0);
		curve();
	}
	glColor3fv(color2);
	for (int i = 0; i < 20; i++)
	{
		glTranslatef(0, 0.05, 0.0);
		curve();
	}

	glPopMatrix();
        glPushMatrix();
	glColor3f(0, 0, 0);
	glBegin(GL_POLYGON);
	glVertex2f(1.5, 2);
	glVertex2f(2, 2);
	glVertex2f(2, 12.5);
	glVertex2f(1.5, 12.5);
	glEnd();
	glPopMatrix();
	glFlush();
	glutSwapBuffers();
}
void animate()
{

	p1[1][0] += 0.001* sin(th*pi /20);
	p1[1][1] += 0.0005* sin(th*pi /20);
	p1[2][0] -= 0.001 * sin((th)*pi /30);
	p1[2][1] -= 0.0005* sin((th)*pi /30);
	p1[3][0] -= 0.001* sin(th*pi /20);
	p1[3][1] -= 0.0005*sin((th)*pi /20);

	th += 0.01;
	glutPostRedisplay();
}
void menu(int id)
{
	if (id == 1)
	{
		color1[0] = 1;
		color1[1] = 0;
		color1[2] = 0;
		color2[0] = 0;
		color2[1] = 0;
		color2[2] = 1;
	}
	if (id == 2)
	{

		color1[0] = 1;
		color1[1] = 0;
		color1[2] = 0;
		color2[0] = 1;
		color2[1] = 1;
		color2[2] = 0;
	}
	if(id==0)
    {
        glutDestroyWindow(win);
        exit(0);
    }
}

int main(int argc, char **argv)
{
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);
	glutInitWindowSize(500, 500);
	glutInitWindowPosition(100, 100);
	win=glutCreateWindow("flag");
	glutDisplayFunc(render);
	glutReshapeFunc(config);
	glutIdleFunc(animate);
	glutCreateMenu(menu);
	glutAddMenuEntry("red, blue", 1);
	glutAddMenuEntry("red,yellow", 2);
	glutAddMenuEntry("Exit",0);
	glutAttachMenu(GLUT_RIGHT_BUTTON);
	glutMainLoop();
}

LAB-09

#include<windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <GL/glut.h>


float x1,x2,x3,x4,y1,y2,y3,y4;
int fillFlag=0,win;

void edgedetect(float x1,float y1,float x2,float y2,int *le,int *re)
{
	float mx,x,temp;
	int i;
	if((y2-y1)<0) // we swape so we don't get a negative slope
	{

		temp=y1;
		y1=y2;
		y2=temp;
		temp=x1;
		x1=x2;
		x2=temp;
	}

	if((y2-y1)!=0)  // to find the slope if not zero i'e not only a horizontal line
		mx=(x2-x1)/(y2-y1);

	else
		mx=x2-x1;

// slope is mx

	x=x1;
	for(i=y1;i<=y2;i++)  // follow along the edge of the polygon
	{

		if(x < le[i] )
			le[i]=x;

		if(x > re[i])
			re[i]=x;

		x+=mx;

	}
}


void draw_pixel(int x,int y)
{
	glColor3f(1.0,1.0,0.0);

	glBegin(GL_POINTS);
	glVertex2i(x,y);
	glEnd();
}

void scanfill(float x1,float y1,float x2,float y2,float x3,float y3,float x4,float y4)

{
	int le[500],re[500]; // left edge and right edge
	int i,y;

	for(i=0;i<500;i++)
	{

		le[i]=500;
		re[i]=0;
	}
	edgedetect(x1,y1,x2,y2,le,re);
	edgedetect(x2,y2,x3,y3,le,re);
	edgedetect(x3,y3,x4,y4,le,re);
	edgedetect(x4,y4,x1,y1,le,re);

	for(y=0;y<500;y++)
	{
		for(i=le[y];i<re[y];i++)
		draw_pixel(i,y);
	}
}


void display()
{

	x1=200.0;y1=200.0;x2=100.0;y2=300.0;x3=200.0;y3=400.0;x4=300.0;y4=300.0;
	glClear(GL_COLOR_BUFFER_BIT);
	glColor3f(0.0, 0.0, 1.0);
	glBegin(GL_LINE_LOOP);
	glVertex2f(x1,y1);
	glVertex2f(x2,y2);
	glVertex2f(x3,y3);
	glVertex2f(x4,y4);
	glEnd();
	if(fillFlag==1)
	    scanfill(x1,y1,x2,y2,x3,y3,x4,y4);
	glFlush();
}

void init()
{
	glClearColor(1.0,1.0,1.0,1.0);
	glColor3f(1.0,0.0,0.0);
	glPointSize(1.0);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluOrtho2D(0.0,499.0,0.0,499.0);
}

void fillMenu(int option)
{
	if(option==1)
		fillFlag=1;
	else if (option==2)
		fillFlag=2;
		else
        {
           glutDestroyWindow(win);
        exit(0);
        }


	display();
}

int main(int argc, char **argv)
{
	glutInit(&argc,argv);
	glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);
	glutInitWindowSize(500,500);
	glutInitWindowPosition(0,0);
	win=glutCreateWindow("Filling a Polygon using Scan-line Algorithm");
	init();
	glutDisplayFunc(display);

	glutCreateMenu(fillMenu);
	glutAddMenuEntry("Fill Polygon",1);
	glutAddMenuEntry("Empty Polygon",2);
    glutAddMenuEntry("Exit",0);
	glutAttachMenu(GLUT_RIGHT_BUTTON);
    glutMainLoop();
}
